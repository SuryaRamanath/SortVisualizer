{"version":3,"sources":["algorithms/Utility.js","algorithms/QuickSort.js","algorithms/MergeSort.js","algorithms/SelectionSort.js","algorithms/CountSort.js","algorithms/HeapSort.js","sortVisualizer/SortVisualizer.jsx","algorithms/InsertionSort.js","algorithms/BubbleSort.js","App.js","serviceWorker.js","index.js"],"names":["swap","arr","index1","index2","temp","getQuickSortAnimations","copy","animations","quickSortHelper","left","right","part","i","j","pivot","push","partition","length","getMergeSortAnimations","len","mergeSortHelper","aux","mid","Math","floor","k","merge","Array","getSelectionSortAnimations","array","minindex","selectionSort","getCountSortAnimations","n","output","from","_","p","count","l","countSort","getHeapSortAnimations","heapify","heapSort","largest","r","SortVisualizer","props","useState","setArr","isSorting","setIsSorting","isSorted","setIsSorted","containerRef","useRef","initialiseArray","resetArrayColour","random","animateArrayUpdate","forEach","index","comparison","swapped","setTimeout","prevArr","newValue","newArr","animateArrayAccess","arrayBars","current","children","arrayBarStyle","style","backgroundColor","animateSortedArray","DELAY","useEffect","className","ref","map","barHeight","height","width","key","onClick","getInsertionSortAnimations","bubbleSort","getBubbleSortAnimations","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.7bc25ce4.chunk.js","sourcesContent":["export function swap(arr, index1, index2) {\n  const temp = arr[index1];\n  arr[index1] = arr[index2];\n  arr[index2] = temp;\n}\n","import { swap } from './Utility';\n\nexport function getQuickSortAnimations(arr) {\n  const copy = [...arr];\n  const animations = [];\n  quickSortHelper(copy, 0, copy.length - 1, animations);\n  return animations;\n}\n\nfunction quickSortHelper(arr, left, right, animations) {\n  if (right <= left) return;\n  const part = partition(arr, left, right, animations);\n  quickSortHelper(arr, left, part, animations);\n  quickSortHelper(arr, part + 1, right, animations);\n}\n\nfunction partition(arr, left, right, animations) {\n  let i = left;\n  let j = right + 1;\n  const pivot = arr[left];\n  while (true) {\n    while (arr[++i] <= pivot) {\n      if (i === right) break;\n      animations.push([[i], false]);\n    }\n    while (arr[--j] >= pivot) {\n      if (j === left) break;\n      animations.push([[j], false]);\n    }\n    if (j <= i) break;\n    animations.push([[i, arr[j]], true]);\n    animations.push([[j, arr[i]], true]);\n    swap(arr, i, j);\n  }\n  animations.push([[left, arr[j]], true]);\n  animations.push([[j, arr[left]], true]);\n  swap(arr, left, j);\n  return j;\n}\n","export function getMergeSortAnimations(arr) {\n  const copy = [...arr];\n  const len = copy.length;\n  const aux = Array(len);\n  const animations = [];\n  mergeSortHelper(copy, aux, 0, len - 1, animations);\n  return animations;\n}\n\nfunction mergeSortHelper(arr, aux, left, right, animations) {\n  if (right <= left) return;\n  const mid = left + Math.floor((right - left) / 2);\n  mergeSortHelper(arr, aux, left, mid, animations);\n  mergeSortHelper(arr, aux, mid + 1, right, animations);\n  merge(arr, aux, left, mid, right, animations);\n}\n\nfunction merge(arr, aux, left, mid, right, animations) {\n  for (let i = left; i <= right; i++) aux[i] = arr[i];\n  let i = left;\n  let j = mid + 1;\n  for (let k = left; k <= right; k++) {\n    if (i > mid) {\n      animations.push([[j], false]);\n      animations.push([[k, aux[j]], true]);\n      arr[k] = aux[j++];\n    } else if (j > right) {\n      animations.push([[i], false]);\n      animations.push([[k, aux[i]], true]);\n      arr[k] = aux[i++];\n    } else if (aux[j] < aux[i]) {\n      animations.push([[i, j], false]);\n      animations.push([[k, aux[j]], true]);\n      arr[k] = aux[j++];\n    } else {\n      animations.push([[i, j], false]);\n      animations.push([[k, aux[i]], true]);\n      arr[k] = aux[i++];\n    }\n  }\n}\n","import { swap } from './Utility';\n\nexport function getSelectionSortAnimations(array){\n    const animations=[]\n    const copy = [...array];\n    if(array.length <=1) return array;\n    // const auxiliaryArray = array.slice();\n  selectionSort(copy, animations)\n  return animations\n}\nfunction  selectionSort(array,animations){\n    var minindex;\n   \n    for(var i = 0; i < array.length-1; i++){\n        minindex =i;\n\n\n\n        for(var j=i+1;j<array.length;j++){\n\n\n            animations.push([[i,j],false]);\n            animations.push([[i,j],false]);\n            if(array[j]<array[minindex]){\n                minindex=j;\n            }\n        }\n        animations.push([[i,array[minindex]],true])\n        animations.push([[minindex,array[i]],true])\n        swap(array,i,minindex);\n      \n      }\n}","\n\nexport function getCountSortAnimations(array) {\n  const animations = [];\n  const copy = [...array];\n  if (array.length <= 1) return array;\n  // const auxiliaryArray = array.slice();\n  countSort(copy, animations);\n  return animations;\n}\nfunction countSort(array, animations) {\n  // for(var i = 0; i < array.length-1; i++){\n  //     minindex =i;\n\n  //     for(var j=i+1;j<array.length;j++){\n\n  //         animations.push([[i,j],false]);\n  //         animations.push([[i,j],false]);\n  //         if(array[j]<array[minindex]){\n  //             minindex=j;\n  //         }\n  //     }\n  //     animations.push([[i,array[minindex]],true])\n  //     animations.push([[minindex,array[i]],true])\n  //     swap(array,i,minindex);\n\n  //   }\n\n  var n = array.length;\n\n  // The output character array that will have sorted arr\n  var output = Array.from({ length: n }, (_, p) => 0);\n\n  // Create a count array to store count of individual\n  // characters and initialize count array as 0\n  var count = Array.from({ length: 256 }, (_, p) => 0);\n\n  // store count of each character\n  for (var i = 0; i < n; ++i) {\n    animations.push([[i],false]);\n    ++count[array[i]];\n  }\n\n  // Change count[i] so that count[i] now contains actual\n  // position of this character in output array\n  for (var j = 1; j <= 255; ++j) count[j] += count[j - 1];\n\n  // Build the output character array\n  // To make it stable we are operating in reverse order.\n  for (var k = n - 1; k >= 0; k--) {\n    output[count[array[k]] - 1] = array[k];\n    --count[array[k]];\n  }\n\n  // Copy the output array to arr, so that arr now\n  // contains sorted characters\n\n\n  for (var l = 0; l < n; ++l){\n    animations.push([[l,output[l]],true])\n    array[l] = output[l];\n  \n} \n}\n","import { swap } from \"./Utility\";\n\nexport function getHeapSortAnimations(arr) {\n  const len = arr.length;\n  const animations = [];\n  heapSort(arr, len, animations);\n  return animations;\n}\n\nfunction heapSort(arr, n, animations) {\n  for (var i = Math.floor(n / 2) - 1; i >= 0; i--) {\n    heapify(arr, n, i, animations);\n  }\n\n  for (var k = n - 1; k > 0; k--) {\n    animations.push([[0, arr[k]], true]);\n    animations.push([[k, arr[0]], true]);\n\n    swap(arr, 0, k);\n\n    heapify(arr, k, 0, animations);\n  }\n}\n\nfunction heapify(arr, n, i, animations) {\n  var largest = i; // Initialize largest as root\n  var l = 2 * i + 1; // left = 2*i + 1\n  var r = 2 * i + 2; // right = 2*i + 2\n\n  // If left child is larger than root\n  if (l < n && arr[l] > arr[largest]) {\n    animations.push([[l, largest], false]);\n    animations.push([[l, largest], false]);\n    largest = l;\n  }\n\n  // If right child is larger than largest so far\n  if (r < n && arr[r] > arr[largest]) {\n    animations.push([[r, largest], false]);\n    animations.push([[r, largest], false]);\n    largest = r;\n  }\n\n  // If largest is not root\n  if (largest !== i) {\n    animations.push([[i, arr[largest]], true]);\n    animations.push([[largest, arr[i]], true]);\n\n    swap(arr, i, largest);\n\n    // Recursively heapify the affected sub-tree\n    heapify(arr, n, largest, animations);\n  }\n}\n","import React, { useState, useEffect, useRef } from 'react';\nimport './SortVisualizer.css';\nimport { getQuickSortAnimations } from '../algorithms/QuickSort';\nimport { getInsertionSortAnimations } from '../algorithms/InsertionSort';\nimport { getMergeSortAnimations } from '../algorithms/MergeSort';\nimport { getBubbleSortAnimations } from '../algorithms/BubbleSort';\nimport { getSelectionSortAnimations } from '../algorithms/SelectionSort';\nimport { getCountSortAnimations } from '../algorithms/CountSort';\nimport { getHeapSortAnimations } from '../algorithms/HeapSort';\nconst ARR_LEN = 150;\nconst DELAY = 3;\nconst ACCESSED_COLOUR = 'red';\nconst SORTED_COLOUR = '#ef18f2';\n\nexport default function SortVisualizer(props) {\n  const [arr, setArr] = useState([]);\n  const [isSorting, setIsSorting] = useState(false);\n  const [isSorted, setIsSorted] = useState(false);\n  const containerRef = useRef(null);\n\n  useEffect(initialiseArray, []);\n\n  function initialiseArray() {\n    if (isSorting) return;\n    if (isSorted) resetArrayColour();\n    setIsSorted(false);\n    const arr = [];\n    \n      \n      for(let i=0;i<ARR_LEN;i++){\n        arr.push(Math.floor(Math.random()*(60)+5));\n      }\n      setArr(arr)\n    \n  }\n\n  function bubbleSort() {\n    const animations =getBubbleSortAnimations(arr);\n    animateArrayUpdate(animations)\n  }\n  function selectionSort(){\n    const animations =getSelectionSortAnimations(arr);\n    animateArrayUpdate(animations)\n  }\n  function heapSort(){\n    const animations =getHeapSortAnimations(arr);\n    animateArrayUpdate(animations);\n  }\n\n  function mergeSort() {\n    const animations = getMergeSortAnimations(arr);\n   \n    animateArrayUpdate(animations);\n  }\n\n  function insertionSort() {\n    const animations = getInsertionSortAnimations(arr);\n    animateArrayUpdate(animations);\n  }\n\n  function quickSort() {\n    const animations = getQuickSortAnimations(arr);\n    animateArrayUpdate(animations);\n  }\n  function countSort() {\n    const animations = getCountSortAnimations(arr);\n    animateArrayUpdate(animations);\n  }\n\n  function animateArrayUpdate(animations) {\n    if (isSorting) return;\n    setIsSorting(true);\n    animations.forEach(([comparison, swapped], index) => {\n      setTimeout(() => {\n        if (!swapped) {\n          if (comparison.length === 2) {\n            const [i, j] = comparison;\n            animateArrayAccess(i);\n            animateArrayAccess(j);\n          } else {\n            const [i] = comparison;\n            animateArrayAccess(i);\n          }\n        } else {\n          setArr((prevArr) => {\n            const [k, newValue] = comparison;\n            const newArr = [...prevArr];\n            newArr[k] = newValue;\n            return newArr;\n          });\n        }\n      }, index * DELAY);\n    });\n    setTimeout(() => {\n      animateSortedArray();\n    }, animations.length * DELAY);\n  }\n\n  function animateArrayAccess(index) {\n    const arrayBars = containerRef.current.children;\n    const arrayBarStyle = arrayBars[index].style;\n    setTimeout(() => {\n      arrayBarStyle.backgroundColor = ACCESSED_COLOUR;\n    }, DELAY);\n    setTimeout(() => {\n      arrayBarStyle.backgroundColor = '';\n    }, DELAY * 2);\n  }\n\n  function animateSortedArray() {\n    const arrayBars = containerRef.current.children;\n    for (let i = 0; i < arrayBars.length; i++) {\n      const arrayBarStyle = arrayBars[i].style;\n      setTimeout(\n        () => (arrayBarStyle.backgroundColor = SORTED_COLOUR),\n        i * DELAY,\n      );\n    }\n    setTimeout(() => {\n      setIsSorted(true);\n      setIsSorting(false);\n    }, arrayBars.length * DELAY);\n  }\n\n  function resetArrayColour() {\n    const arrayBars = containerRef.current.children;\n    for (let i = 0; i < arr.length; i++) {\n      const arrayBarStyle = arrayBars[i].style;\n      arrayBarStyle.backgroundColor = '';\n    }\n  }\n\n  return (\n    <div className=\"visualizer-container\">\n      <div className=\"array-container\" ref={containerRef}>\n        {arr.map((barHeight, index) => (\n          <div\n            className=\"array-bar\"\n            style={{\n              height: `${barHeight}vmin`,\n              width: `${30 / ARR_LEN}vw`,\n            }}\n            key={index}\n          ></div>\n        ))}\n      </div>\n      <footer className=\"app-footer\">\n        <ul>\n          <li>\n            <button className=\"app-button\" onClick={initialiseArray}>\n              Create new array\n            </button>\n          </li>\n          <li>\n            <button className=\"app-button\" onClick={mergeSort}>\n              Merge sort\n            </button>\n          </li>\n          <li>\n            <button className=\"app-button\" onClick={insertionSort}>\n              Insertion sort\n            </button>\n          </li>\n          <li>\n            <button className=\"app-button\" onClick={quickSort}>\n              Quick sort\n            </button>\n          </li>\n          <li>\n            <button className=\"app-button\" onClick={bubbleSort}>\n              Bubble sort\n            </button>\n          </li>\n          <li>\n            <button className=\"app-button\" onClick={selectionSort}>\n              Selection sort\n            </button>\n          </li>\n          <li>\n            <button className=\"app-button\" onClick={countSort}>\n              Count sort\n            </button>\n          </li>\n          <li>\n            <button className=\"app-button\" onClick={heapSort}>\n              Heap Sort\n            </button>\n          </li>\n        </ul>\n      </footer>\n    </div>\n  );\n}\n\n\n","import { swap } from \"./Utility\";\n\nexport function getInsertionSortAnimations(arr) {\n  const copy = [...arr];\n  const animations = [];\n  for (let i = 1; i < copy.length; i++) {\n    for (let j = i - 1; j >= 0; j--) {\n      animations.push([[j, j + 1], false]);\n      if (copy[j + 1] < copy[j]) {\n        animations.push([[j, copy[j + 1]], true]);\n        animations.push([[j + 1, copy[j]], true]);\n        swap(copy, j, j + 1);\n      } else break;\n    }\n  }\n  return animations;\n}\n","export function getBubbleSortAnimations(array){\n    const animations=[]\n    const copy = [...array];\n    if(array.length <=1) return array;\n    // const auxiliaryArray = array.slice();\n  bubbleSort(copy, animations)\n  return animations\n}\nfunction bubbleSort(array,animations){\n    for(var i = 0; i < array.length; i++){\n    \n        // Last i elements are already in place \n        for(var j = 0; j < ( array.length - i -1 ); j++){\n\n            animations.push([[j,j+1],false]);\n            animations.push([[j,j+1],false]);\n           \n          // Checking if the item at present iteration\n          // is greater than the next iteration\n          if(array[j] > array[j+1]){\n             \n            animations.push([[j,array[j+1]],true])\n            animations.push([[j+1,array[j]],true])\n            // If the condition is true then swap them\n            var temp = array[j]\n            array[j] = array[j + 1]\n            array[j+1] = temp\n          }\n        //   else{\n        //       animations.push([-1,-1]);\n        //       animations.push([-1,-1]);\n\n        //   }\n        }\n      }\n}","import React from \"react\";\nimport SortVisualizer from \"./sortVisualizer/SortVisualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SortVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}